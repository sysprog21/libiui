#!/usr/bin/env python3
"""
MD3 Validation Code Generator

Reads src/md3-spec.dsl and generates:
  - src/md3-flags-gen.inc     (violation enum - single source of truth)
  - src/md3-validate-gen.inc  (validation functions)
  - tests/test-md3-gen.inc    (test cases)

Usage:
  python3 scripts/gen-md3-validate.py
"""

import re
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional

# =============================================================================
# C Code Templates - Centralized to eliminate duplication
# =============================================================================

# Violation flags - single source of truth for enum generation
VIOLATION_FLAGS = (
    "HEIGHT_LOW",
    "SIZE_MISMATCH",
    "TOUCH_TARGET",
    "GRID_ALIGN",
    "STATE_OPACITY",
    "CORNER_RADIUS",
    "THUMB_SIZE",
    "ICON_SIZE",
    "PADDING",
    "GAP",
    "INDICATOR",
    "WIDTH_LOW",
)


def generate_flags_file() -> str:
    """Generate the md3-flags-gen.inc file with violation enum."""
    lines = [
        "/* AUTO-GENERATED by scripts/gen-md3-validate.py - DO NOT EDIT */",
        "/* MD3 violation flags - single source of truth */",
        "",
        "#ifndef MD3_FLAGS_GEN_INC",
        "#define MD3_FLAGS_GEN_INC",
        "",
        "/* Violation flags (bitmask) */",
        "typedef enum {",
        "    MD3_OK = 0,",
    ]
    for i, flag in enumerate(VIOLATION_FLAGS):
        lines.append(f"    MD3_{flag} = 1 << {i},")
    lines.extend(
        [
            "} md3_violation_t;",
            "",
            "#endif /* MD3_FLAGS_GEN_INC */",
            "",
        ]
    )
    return "\n".join(lines)


HEADER_START = """\
/* AUTO-GENERATED by scripts/gen-md3-validate.py - DO NOT EDIT */
/* Extended MD3 validators generated from src/md3-spec.dsl */

#ifndef MD3_VALIDATE_GEN_INC
#define MD3_VALIDATE_GEN_INC

#include "md3-validate.h" /* For md3_violation_t, md3_dp_to_px, etc. */
"""

# Extended helpers (md3_dp_to_px, md3_check_grid_align, md3_check_touch_target
# are already provided by md3-validate.h)
HELPER_FUNCS = """\
/* Exact size check (returns MD3_SIZE_MISMATCH if outside tolerance) */
static inline md3_violation_t md3_check_exact(int px, float dp, int tol, float scale)
{
    int expected = md3_dp_to_px(scale, dp);
    int diff = px - expected;
    return (diff < -tol || diff > tol) ? MD3_SIZE_MISMATCH : MD3_OK;
}

/* Minimum size check with configurable flag */
static inline md3_violation_t md3_check_min(int px, float dp, float scale, md3_violation_t flag)
{
    int min = md3_dp_to_px(scale, dp);
    return (px < min) ? flag : MD3_OK;
}
"""

HEADER_EPILOGUE = "#endif /* MD3_VALIDATE_GEN_INC */\n"

TEST_PREAMBLE = """\
/* AUTO-GENERATED by scripts/gen-md3-validate.py - DO NOT EDIT */

/* Include this file in test-spec.c after including the generated header */
"""


# =============================================================================
# Data Classes
# =============================================================================


@dataclass
class Component:
    name: str
    height_min: Optional[float] = None
    height_exact: Optional[float] = None
    height_tolerance: int = 0
    size_exact: Optional[float] = None
    size_tolerance: int = 0
    width_exact: Optional[float] = None
    touch_target: Optional[float] = None
    corner_radius: Optional[float] = None
    corner_radius_token: Optional[str] = None  # e.g., 'medium', 'large'
    track_height: Optional[float] = None
    track_width: Optional[float] = None
    thumb_idle: Optional[float] = None
    thumb_pressed: Optional[float] = None
    thumb_size: Optional[float] = None
    icon_size: Optional[float] = None
    padding_h: Optional[float] = None
    padding_v: Optional[float] = None
    padding: Optional[float] = None  # generic padding
    gap: Optional[float] = None
    icon_label_gap: Optional[float] = None
    action_gap: Optional[float] = None
    min_width: Optional[float] = None
    max_width: Optional[float] = None
    min_height: Optional[float] = None  # min_height (not height MIN)
    max_height: Optional[float] = None
    indicator_height: Optional[float] = None
    indicator_width: Optional[float] = None
    item_height: Optional[float] = None
    icon_container: Optional[float] = None
    button_height: Optional[float] = None
    drag_handle_width: Optional[float] = None
    drag_handle_height: Optional[float] = None
    avatar_size: Optional[float] = None
    divider_inset: Optional[float] = None
    offset: Optional[float] = None
    collapsed_height: Optional[float] = None
    expanded_width: Optional[float] = None
    selector_size: Optional[float] = None
    center_dot: Optional[float] = None
    header_height: Optional[float] = None
    suggestion_height: Optional[float] = None
    content_spacing: Optional[float] = None


@dataclass
class StateLayer:
    hover: int = 8
    focus: int = 12
    press: int = 12
    drag: int = 16
    disable: int = 38


@dataclass
class ShapeTokens:
    none: float = 0.0
    extra_small: float = 4.0
    small: float = 8.0
    medium: float = 12.0
    large: float = 16.0
    extra_large: float = 28.0


@dataclass
class TypographyScale:
    headline_small: float = 24.0
    title_large: float = 22.0
    title_medium: float = 16.0
    title_small: float = 14.0
    body_large: float = 16.0
    body_medium: float = 14.0
    body_small: float = 12.0
    label_large: float = 14.0
    label_medium: float = 12.0
    label_small: float = 11.0


@dataclass
class LayoutTier:
    """Size-class-keyed layout values (compact/medium/expanded)."""

    compact: float = 0.0
    medium: float = 0.0
    expanded: float = 0.0
    large: float = 0.0
    extra_large: float = 0.0


@dataclass
class Spec:
    components: dict = field(default_factory=dict)
    grid_unit: float = 4.0
    state_layer: StateLayer = field(default_factory=StateLayer)
    shape_tokens: ShapeTokens = field(default_factory=ShapeTokens)
    typography_scale: TypographyScale = field(default_factory=TypographyScale)
    window_size_class: LayoutTier = field(default_factory=LayoutTier)
    layout_columns: LayoutTier = field(default_factory=LayoutTier)
    layout_margin: LayoutTier = field(default_factory=LayoutTier)
    layout_gutter: LayoutTier = field(default_factory=LayoutTier)


# =============================================================================
# DSL Parser
# =============================================================================

# Property patterns: (regex, attribute_name, type_converter)
# More specific patterns must come before more general patterns
COMPONENT_PROPS = [
    (r"height\s+MIN\s+(\d+(?:\.\d+)?)", "height_min", float),
    (r"height\s+EXACT\s+(\d+(?:\.\d+)?)\s*(?:±(\d+))?", "height_exact", float),
    (r"size\s+EXACT\s+(\d+(?:\.\d+)?)\s*(?:±(\d+))?", "size_exact", float),
    (r"width\s+EXACT\s+(\d+(?:\.\d+)?)", "width_exact", float),
    (r"touch_target\s+(\d+(?:\.\d+)?)", "touch_target", float),
    (r"corner_radius\s+@shape\.(\w+)", "corner_radius_token", str),  # token ref
    (r"corner_radius\s+(\d+(?:\.\d+)?)", "corner_radius", float),
    (r"track_height\s+(\d+(?:\.\d+)?)", "track_height", float),
    (r"track_width\s+(\d+(?:\.\d+)?)", "track_width", float),
    (r"thumb_idle\s+(\d+(?:\.\d+)?)", "thumb_idle", float),
    (r"thumb_pressed\s+(\d+(?:\.\d+)?)", "thumb_pressed", float),
    (r"thumb_size\s+(\d+(?:\.\d+)?)", "thumb_size", float),
    (r"icon_size\s+(\d+(?:\.\d+)?)", "icon_size", float),
    (r"icon_container\s+(\d+(?:\.\d+)?)", "icon_container", float),
    (r"icon_label_gap\s+(\d+(?:\.\d+)?)", "icon_label_gap", float),
    (r"padding_h\s+(\d+(?:\.\d+)?)", "padding_h", float),
    (r"padding_v\s+(\d+(?:\.\d+)?)", "padding_v", float),
    (r"padding\s+(\d+(?:\.\d+)?)", "padding", float),  # generic padding (after _h/_v)
    (r"gap\s+(\d+(?:\.\d+)?)", "gap", float),
    (r"action_gap\s+(\d+(?:\.\d+)?)", "action_gap", float),
    (r"min_width\s+(\d+(?:\.\d+)?)", "min_width", float),
    (r"max_width\s+(\d+(?:\.\d+)?)", "max_width", float),
    (r"min_height\s+(\d+(?:\.\d+)?)", "min_height", float),
    (r"max_height\s+(\d+(?:\.\d+)?)", "max_height", float),
    (r"indicator_height\s+(\d+(?:\.\d+)?)", "indicator_height", float),
    (r"indicator_width\s+(\d+(?:\.\d+)?)", "indicator_width", float),
    (r"item_height\s+(\d+(?:\.\d+)?)", "item_height", float),
    (r"button_height\s+(\d+(?:\.\d+)?)", "button_height", float),
    (r"drag_handle_width\s+(\d+(?:\.\d+)?)", "drag_handle_width", float),
    (r"drag_handle_height\s+(\d+(?:\.\d+)?)", "drag_handle_height", float),
    (r"avatar_size\s+(\d+(?:\.\d+)?)", "avatar_size", float),
    (r"divider_inset\s+(\d+(?:\.\d+)?)", "divider_inset", float),
    (r"offset\s+(\d+(?:\.\d+)?)", "offset", float),
    (r"collapsed_height\s+(\d+(?:\.\d+)?)", "collapsed_height", float),
    (r"expanded_width\s+(\d+(?:\.\d+)?)", "expanded_width", float),
    (r"selector_size\s+(\d+(?:\.\d+)?)", "selector_size", float),
    (r"center_dot\s+(\d+(?:\.\d+)?)", "center_dot", float),
    (r"header_height\s+(\d+(?:\.\d+)?)", "header_height", float),
    (r"suggestion_height\s+(\d+(?:\.\d+)?)", "suggestion_height", float),
    (r"content_spacing\s+(\d+(?:\.\d+)?)", "content_spacing", float),
]


def parse_dsl(content: str) -> Spec:
    """Parse the MD3 DSL content."""
    spec = Spec()
    current_component = None
    current_block = None  # 'state_layer', 'shape', 'typography', or None
    warnings = []

    for line_num, line in enumerate(content.split("\n"), 1):
        line = line.strip()
        if not line or line.startswith("#"):
            continue

        # Component definition
        if m := re.match(r"COMPONENT\s+(\w+)\s*\{", line):
            current_component = Component(name=m.group(1))
            spec.components[m.group(1)] = current_component
            continue

        # Global blocks
        if m := re.match(r"GLOBAL\s+grid_unit\s+(\d+(?:\.\d+)?)", line):
            spec.grid_unit = float(m.group(1))
            continue
        if re.match(r"GLOBAL\s+state_layer\s*\{", line):
            current_block = "state_layer"
            continue
        if re.match(r"GLOBAL\s+shape\s*\{", line):
            current_block = "shape"
            continue
        if re.match(r"GLOBAL\s+typography\s*\{", line):
            current_block = "typography"
            continue
        if re.match(r"GLOBAL\s+window_size_class\s*\{", line):
            current_block = "window_size_class"
            continue
        if re.match(r"GLOBAL\s+layout_columns\s*\{", line):
            current_block = "layout_columns"
            continue
        if re.match(r"GLOBAL\s+layout_margin\s*\{", line):
            current_block = "layout_margin"
            continue
        if re.match(r"GLOBAL\s+layout_gutter\s*\{", line):
            current_block = "layout_gutter"
            continue

        # End of block
        if line == "}":
            if current_block:
                current_block = None
            else:
                current_component = None
            continue

        # Block properties
        if current_block:
            if m := re.match(r"(\w+)\s+(\d+(?:\.\d+)?)", line):
                obj = {
                    "state_layer": spec.state_layer,
                    "shape": spec.shape_tokens,
                    "typography": spec.typography_scale,
                    "window_size_class": spec.window_size_class,
                    "layout_columns": spec.layout_columns,
                    "layout_margin": spec.layout_margin,
                    "layout_gutter": spec.layout_gutter,
                }[current_block]
                converter = int if current_block == "state_layer" else float
                setattr(obj, m.group(1), converter(m.group(2)))
                continue
            else:
                warnings.append(
                    f"line {line_num}: unrecognized in GLOBAL {current_block}: {line}"
                )
                continue

        # Component properties
        if current_component:
            matched = False
            for pattern, attr, conv in COMPONENT_PROPS:
                if m := re.match(pattern, line):
                    setattr(current_component, attr, conv(m.group(1)))
                    # Handle tolerance for EXACT patterns
                    if attr in ("height_exact", "size_exact") and m.lastindex >= 2:
                        if attr == "height_exact":
                            current_component.height_tolerance = int(m.group(2) or 0)
                        elif attr == "size_exact":
                            current_component.size_tolerance = int(m.group(2) or 0)
                    matched = True
                    break
            if not matched:
                warnings.append(
                    f"line {line_num}: unrecognized in COMPONENT {current_component.name}: {line}"
                )
            continue

        # Line outside any block that doesn't match known patterns
        warnings.append(f"line {line_num}: unrecognized top-level: {line}")

    # Print warnings to stderr
    for warn in warnings:
        print(f"Warning: {warn}", file=sys.stderr)

    return spec


# =============================================================================
# Code Generation Helpers
# =============================================================================


def emit_func(name: str, params: str, body: str) -> str:
    """Generate a static inline function."""
    return f"static inline md3_violation_t {name}({params})\n{{\n{body}\n}}"


# =============================================================================
# Header Generator
# =============================================================================


def generate_header(spec: Spec) -> str:
    """Generate the validation include file."""
    # Note: md3_violation_t enum and basic helpers (md3_dp_to_px, md3_check_grid_align,
    # md3_check_touch_target) are provided by md3-validate.h - we only generate extensions
    lines = [HEADER_START, ""]

    # Shape tokens (must come before component validators that reference them)
    lines.append("/* MD3 Shape Tokens (corner radii in dp) */")
    for attr in ["none", "extra_small", "small", "medium", "large", "extra_large"]:
        val = getattr(spec.shape_tokens, attr)
        lines.append(f"#define MD3_SHAPE_{attr.upper()} {val:.1f}f")
    lines.append("")

    # Extended helpers not in md3-validate.h
    lines.append(HELPER_FUNCS)

    # Specialized helpers (md3_check_touch_target is in md3-validate.h)
    # Generic exact-size check helper (reduces code duplication)
    lines.append(
        emit_func(
            "md3_check_exact_dp",
            "int px, float dp, float scale, md3_violation_t flag",
            "    int expected = md3_dp_to_px(scale, dp);\n"
            "    return (px != expected) ? flag : MD3_OK;",
        )
    )
    lines.append("")

    # Specific helpers that delegate to generic
    helpers = [
        (
            "md3_check_touch_target_dp",
            "int w, int h, float scale, float dp",
            "    int min = md3_dp_to_px(scale, dp);\n"
            "    return (w < min || h < min) ? MD3_TOUCH_TARGET : MD3_OK;",
        ),
        (
            "md3_check_corner_radius",
            "int px, float dp, float scale",
            "    return md3_check_exact_dp(px, dp, scale, MD3_CORNER_RADIUS);",
        ),
        (
            "md3_check_icon_size",
            "int px, float dp, float scale",
            "    return md3_check_exact_dp(px, dp, scale, MD3_ICON_SIZE);",
        ),
        (
            "md3_check_padding",
            "int px, float dp, float scale",
            "    return md3_check_exact_dp(px, dp, scale, MD3_PADDING);",
        ),
        (
            "md3_check_gap",
            "int px, float dp, float scale",
            "    return md3_check_exact_dp(px, dp, scale, MD3_GAP);",
        ),
        (
            "md3_check_indicator",
            "int px, float dp, float scale",
            "    return md3_check_exact_dp(px, dp, scale, MD3_INDICATOR);",
        ),
    ]
    for name, params, body in helpers:
        lines.append(emit_func(name, params, body))
        lines.append("")

    # Components whose primary validators are already in md3-validate.h
    SKIP_PRIMARY = {"button", "fab", "fab_large", "chip", "textfield"}

    # Component validators
    for name, comp in spec.components.items():
        fn = f"md3_check_{name}"
        lines.append(f"/* {name.replace('_', ' ').title()} validator */")

        # Primary validator (skip if already in md3-validate.h)
        if name not in SKIP_PRIMARY:
            if comp.size_exact is not None:
                lines.append(
                    emit_func(
                        fn,
                        "int size_px, float scale",
                        f"    return md3_check_exact(size_px, {comp.size_exact:.1f}f, "
                        f"{comp.size_tolerance}, scale);",
                    )
                )
            elif comp.height_exact is not None:
                lines.append(
                    emit_func(
                        fn,
                        "int height_px, float scale",
                        f"    return md3_check_exact(height_px, {comp.height_exact:.1f}f, "
                        f"{comp.height_tolerance}, scale);",
                    )
                )
            elif comp.height_min is not None:
                lines.append(
                    emit_func(
                        fn,
                        "int height_px, float scale",
                        f"    return md3_check_min(height_px, {comp.height_min:.1f}f, scale, MD3_HEIGHT_LOW);",
                    )
                )
            elif comp.track_width is not None and comp.track_height is not None:
                lines.append(
                    emit_func(
                        f"{fn}_track",
                        "int w, int h, float scale",
                        f"    int exp_w = md3_dp_to_px(scale, {comp.track_width:.1f}f);\n"
                        f"    int exp_h = md3_dp_to_px(scale, {comp.track_height:.1f}f);\n"
                        f"    return (w != exp_w || h != exp_h) ? MD3_SIZE_MISMATCH : MD3_OK;",
                    )
                )
            elif comp.track_height is not None:
                lines.append(
                    emit_func(
                        f"{fn}_track",
                        "int height_px, float scale",
                        f"    return md3_check_exact(height_px, {comp.track_height:.1f}f, 0, scale);",
                    )
                )

        # Corner radius (supports token reference or explicit value)
        if comp.corner_radius_token is not None:
            token = comp.corner_radius_token.upper()
            lines.append(
                emit_func(
                    f"{fn}_corner",
                    "int radius_px, float scale",
                    f"    return md3_check_corner_radius(radius_px, MD3_SHAPE_{token}, scale);",
                )
            )
        elif comp.corner_radius is not None:
            lines.append(
                emit_func(
                    f"{fn}_corner",
                    "int radius_px, float scale",
                    f"    return md3_check_corner_radius(radius_px, {comp.corner_radius:.1f}f, scale);",
                )
            )

        # Touch target
        if comp.touch_target is not None:
            lines.append(
                emit_func(
                    f"{fn}_touch",
                    "int w, int h, float scale",
                    f"    return md3_check_touch_target_dp(w, h, scale, {comp.touch_target:.1f}f);",
                )
            )

        # Thumb (slider/switch)
        if comp.thumb_idle is not None and comp.thumb_pressed is not None:
            lines.append(
                emit_func(
                    f"{fn}_thumb",
                    "int size_px, int is_pressed, float scale",
                    f"    float dp = is_pressed ? {comp.thumb_pressed:.1f}f : {comp.thumb_idle:.1f}f;\n"
                    f"    int expected = md3_dp_to_px(scale, dp);\n"
                    f"    return (size_px != expected) ? MD3_THUMB_SIZE : MD3_OK;",
                )
            )
        elif comp.thumb_size is not None:
            lines.append(
                emit_func(
                    f"{fn}_thumb",
                    "int size_px, float scale",
                    f"    int expected = md3_dp_to_px(scale, {comp.thumb_size:.1f}f);\n"
                    f"    return (size_px != expected) ? MD3_THUMB_SIZE : MD3_OK;",
                )
            )

        # Icon size
        if comp.icon_size is not None:
            lines.append(
                emit_func(
                    f"{fn}_icon",
                    "int size_px, float scale",
                    f"    return md3_check_icon_size(size_px, {comp.icon_size:.1f}f, scale);",
                )
            )

        # Width (exact or min)
        if comp.width_exact is not None:
            lines.append(
                emit_func(
                    f"{fn}_width",
                    "int width_px, float scale",
                    f"    return md3_check_exact(width_px, {comp.width_exact:.1f}f, 0, scale);",
                )
            )
        elif comp.min_width is not None:
            lines.append(
                emit_func(
                    f"{fn}_width",
                    "int width_px, float scale",
                    f"    return md3_check_min(width_px, {comp.min_width:.1f}f, scale, MD3_WIDTH_LOW);",
                )
            )

        # Padding
        if comp.padding is not None:
            lines.append(
                emit_func(
                    f"{fn}_padding",
                    "int px, float scale",
                    f"    return md3_check_padding(px, {comp.padding:.1f}f, scale);",
                )
            )
        if comp.padding_h is not None:
            lines.append(
                emit_func(
                    f"{fn}_padding_h",
                    "int px, float scale",
                    f"    return md3_check_padding(px, {comp.padding_h:.1f}f, scale);",
                )
            )
        if comp.padding_v is not None:
            lines.append(
                emit_func(
                    f"{fn}_padding_v",
                    "int px, float scale",
                    f"    return md3_check_padding(px, {comp.padding_v:.1f}f, scale);",
                )
            )

        # Item height (for list/navigation components)
        if comp.item_height is not None:
            lines.append(
                emit_func(
                    f"{fn}_item_height",
                    "int height_px, float scale",
                    f"    return md3_check_exact_dp(height_px, {comp.item_height:.1f}f, scale, MD3_SIZE_MISMATCH);",
                )
            )

        # Icon container (for bottom app bar)
        if comp.icon_container is not None:
            lines.append(
                emit_func(
                    f"{fn}_icon_container",
                    "int size_px, float scale",
                    f"    return md3_check_exact_dp(size_px, {comp.icon_container:.1f}f, scale, MD3_SIZE_MISMATCH);",
                )
            )

        # Button height (for dialog buttons)
        if comp.button_height is not None:
            lines.append(
                emit_func(
                    f"{fn}_button_height",
                    "int height_px, float scale",
                    f"    return md3_check_exact_dp(height_px, {comp.button_height:.1f}f, scale, MD3_HEIGHT_LOW);",
                )
            )

        # Drag handle dimensions
        if comp.drag_handle_width is not None:
            lines.append(
                emit_func(
                    f"{fn}_drag_handle_width",
                    "int width_px, float scale",
                    f"    return md3_check_exact_dp(width_px, {comp.drag_handle_width:.1f}f, scale, MD3_SIZE_MISMATCH);",
                )
            )
        if comp.drag_handle_height is not None:
            lines.append(
                emit_func(
                    f"{fn}_drag_handle_height",
                    "int height_px, float scale",
                    f"    return md3_check_exact_dp(height_px, {comp.drag_handle_height:.1f}f, scale, MD3_SIZE_MISMATCH);",
                )
            )

        # Minimum height (distinct from height MIN)
        if comp.min_height is not None:
            lines.append(
                emit_func(
                    f"{fn}_min_height",
                    "int height_px, float scale",
                    f"    return md3_check_min(height_px, {comp.min_height:.1f}f, scale, MD3_HEIGHT_LOW);",
                )
            )

        # Gap
        if comp.gap is not None:
            lines.append(
                emit_func(
                    f"{fn}_gap",
                    "int px, float scale",
                    f"    return md3_check_gap(px, {comp.gap:.1f}f, scale);",
                )
            )

        # Indicator
        if comp.indicator_height is not None:
            lines.append(
                emit_func(
                    f"{fn}_indicator",
                    "int height_px, float scale",
                    f"    return md3_check_indicator(height_px, {comp.indicator_height:.1f}f, scale);",
                )
            )
        if comp.indicator_width is not None:
            lines.append(
                emit_func(
                    f"{fn}_indicator_width",
                    "int width_px, float scale",
                    f"    return md3_check_exact_dp(width_px, {comp.indicator_width:.1f}f, scale, MD3_INDICATOR);",
                )
            )

        # Icon-label gap
        if comp.icon_label_gap is not None:
            lines.append(
                emit_func(
                    f"{fn}_icon_label_gap",
                    "int px, float scale",
                    f"    return md3_check_gap(px, {comp.icon_label_gap:.1f}f, scale);",
                )
            )

        # Action gap
        if comp.action_gap is not None:
            lines.append(
                emit_func(
                    f"{fn}_action_gap",
                    "int px, float scale",
                    f"    return md3_check_gap(px, {comp.action_gap:.1f}f, scale);",
                )
            )

        # Avatar size
        if comp.avatar_size is not None:
            lines.append(
                emit_func(
                    f"{fn}_avatar",
                    "int size_px, float scale",
                    f"    return md3_check_exact_dp(size_px, {comp.avatar_size:.1f}f, scale, MD3_SIZE_MISMATCH);",
                )
            )

        # Divider inset
        if comp.divider_inset is not None:
            lines.append(
                emit_func(
                    f"{fn}_divider_inset",
                    "int px, float scale",
                    f"    return md3_check_exact_dp(px, {comp.divider_inset:.1f}f, scale, MD3_PADDING);",
                )
            )

        # Offset
        if comp.offset is not None:
            lines.append(
                emit_func(
                    f"{fn}_offset",
                    "int px, float scale",
                    f"    return md3_check_exact_dp(px, {comp.offset:.1f}f, scale, MD3_PADDING);",
                )
            )

        # Collapsed height
        if comp.collapsed_height is not None:
            lines.append(
                emit_func(
                    f"{fn}_collapsed_height",
                    "int height_px, float scale",
                    f"    return md3_check_exact_dp(height_px, {comp.collapsed_height:.1f}f, scale, MD3_HEIGHT_LOW);",
                )
            )

        # Expanded width
        if comp.expanded_width is not None:
            lines.append(
                emit_func(
                    f"{fn}_expanded_width",
                    "int width_px, float scale",
                    f"    return md3_check_exact_dp(width_px, {comp.expanded_width:.1f}f, scale, MD3_WIDTH_LOW);",
                )
            )

        # Max height
        if comp.max_height is not None:
            lines.append(
                emit_func(
                    f"{fn}_max_height",
                    "int height_px, float scale",
                    f"    int max_h = md3_dp_to_px(scale, {comp.max_height:.1f}f);\n"
                    f"    return (height_px > max_h) ? MD3_HEIGHT_LOW : MD3_OK;",
                )
            )

        # Max width (already exists for some components)
        if comp.max_width is not None and comp.min_width is None:
            lines.append(
                emit_func(
                    f"{fn}_max_width",
                    "int width_px, float scale",
                    f"    int max_w = md3_dp_to_px(scale, {comp.max_width:.1f}f);\n"
                    f"    return (width_px > max_w) ? MD3_WIDTH_LOW : MD3_OK;",
                )
            )

        # Selector size (for time picker)
        if comp.selector_size is not None:
            lines.append(
                emit_func(
                    f"{fn}_selector",
                    "int size_px, float scale",
                    f"    return md3_check_exact_dp(size_px, {comp.selector_size:.1f}f, scale, MD3_SIZE_MISMATCH);",
                )
            )

        # Center dot (for time picker)
        if comp.center_dot is not None:
            lines.append(
                emit_func(
                    f"{fn}_center_dot",
                    "int size_px, float scale",
                    f"    return md3_check_exact_dp(size_px, {comp.center_dot:.1f}f, scale, MD3_SIZE_MISMATCH);",
                )
            )

        # Header height
        if comp.header_height is not None:
            lines.append(
                emit_func(
                    f"{fn}_header_height",
                    "int height_px, float scale",
                    f"    return md3_check_exact_dp(height_px, {comp.header_height:.1f}f, scale, MD3_HEIGHT_LOW);",
                )
            )

        # Suggestion height
        if comp.suggestion_height is not None:
            lines.append(
                emit_func(
                    f"{fn}_suggestion_height",
                    "int height_px, float scale",
                    f"    return md3_check_exact_dp(height_px, {comp.suggestion_height:.1f}f, scale, MD3_HEIGHT_LOW);",
                )
            )

        # Content spacing
        if comp.content_spacing is not None:
            lines.append(
                emit_func(
                    f"{fn}_content_spacing",
                    "int px, float scale",
                    f"    return md3_check_gap(px, {comp.content_spacing:.1f}f, scale);",
                )
            )

        lines.append("")

    # Typography scale
    lines.append("/* MD3 Typography Scale (font sizes in dp) */")
    for attr in [
        "headline_small",
        "title_large",
        "title_medium",
        "title_small",
        "body_large",
        "body_medium",
        "body_small",
        "label_large",
        "label_medium",
        "label_small",
    ]:
        val = getattr(spec.typography_scale, attr)
        lines.append(f"#define MD3_TYPO_{attr.upper()} {val:.1f}f")
    lines.append("")

    # State layer opacity validation is defined in md3-validate.h
    # Don't regenerate here - just emit the expected values as a comment for reference
    sl = spec.state_layer
    lines.append("/* State layer opacity validation */")
    lines.append(
        f"/* Expected alpha values from DSL: hover={int(sl.hover * 255 / 100)}, "
        f"focus={int(sl.focus * 255 / 100)}, press={int(sl.press * 255 / 100)}, "
        f"drag={int(sl.drag * 255 / 100)}, disable={int(sl.disable * 255 / 100)} */"
    )
    lines.append("/* See md3_check_state_alpha() in md3-validate.h */")
    lines.append("")
    lines.append(HEADER_EPILOGUE)

    return "\n".join(lines)


# =============================================================================
# Test Generator
# =============================================================================


def generate_tests(spec: Spec) -> str:
    """Generate test cases."""
    lines = [TEST_PREAMBLE, ""]

    # Components whose primary validators are tested in test-spec.c
    SKIP_PRIMARY = {"button", "fab", "fab_large", "chip", "textfield"}

    def emit_test(comment: str, *assertions: str):
        """Helper to emit a test block."""
        result = [f"    /* {comment} */"]
        result.extend(f"    {a}" for a in assertions)
        return result

    for name, comp in spec.components.items():
        fn = f"md3_check_{name}"
        lines.append(f"static void test_md3_gen_{name}(void)")
        lines.append("{")
        lines.append(f"    TEST(md3_gen_{name});")

        # Primary validator tests (skip if tested in test-spec.c)
        if name not in SKIP_PRIMARY:
            if comp.size_exact is not None:
                dp, tol = int(comp.size_exact), comp.size_tolerance
                lines.extend(
                    emit_test(
                        f"Exact size {dp}dp ±{tol}px",
                        f"ASSERT_EQ({fn}({dp}, 1.f), MD3_OK);",
                        f"ASSERT_EQ({fn}({dp + tol}, 1.f), MD3_OK);",
                        f"ASSERT_EQ({fn}({dp - tol}, 1.f), MD3_OK);",
                        f"ASSERT_TRUE({fn}({dp - tol - 1}, 1.f) & MD3_SIZE_MISMATCH);",
                        f"ASSERT_TRUE({fn}({dp + tol + 1}, 1.f) & MD3_SIZE_MISMATCH);",
                        f"ASSERT_EQ({fn}({dp * 2}, 2.f), MD3_OK);",
                    )
                )
            elif comp.height_exact is not None:
                dp, tol = int(comp.height_exact), comp.height_tolerance
                lines.extend(
                    emit_test(
                        f"Exact height {dp}dp ±{tol}px",
                        f"ASSERT_EQ({fn}({dp}, 1.f), MD3_OK);",
                        f"ASSERT_TRUE({fn}({dp - tol - 1}, 1.f) & MD3_SIZE_MISMATCH);",
                        f"ASSERT_TRUE({fn}({dp + tol + 1}, 1.f) & MD3_SIZE_MISMATCH);",
                        f"ASSERT_EQ({fn}({dp * 2}, 2.f), MD3_OK);",
                    )
                )
            elif comp.height_min is not None:
                dp = int(comp.height_min)
                lines.extend(
                    emit_test(
                        f"Min height {dp}dp",
                        f"ASSERT_EQ({fn}({dp}, 1.f), MD3_OK);",
                        f"ASSERT_EQ({fn}({dp + 10}, 1.f), MD3_OK);",
                        f"ASSERT_TRUE({fn}({dp - 1}, 1.f) & MD3_HEIGHT_LOW);",
                        f"ASSERT_EQ({fn}({dp * 2}, 2.f), MD3_OK);",
                        f"ASSERT_TRUE({fn}({dp * 2 - 1}, 2.f) & MD3_HEIGHT_LOW);",
                    )
                )
            elif comp.track_width is not None and comp.track_height is not None:
                w, h = int(comp.track_width), int(comp.track_height)
                lines.extend(
                    emit_test(
                        f"Track size {w}x{h}dp",
                        f"ASSERT_EQ({fn}_track({w}, {h}, 1.f), MD3_OK);",
                        f"ASSERT_TRUE({fn}_track({w + 1}, {h}, 1.f) & MD3_SIZE_MISMATCH);",
                        f"ASSERT_TRUE({fn}_track({w}, {h + 1}, 1.f) & MD3_SIZE_MISMATCH);",
                        f"ASSERT_EQ({fn}_track({w * 2}, {h * 2}, 2.f), MD3_OK);",
                    )
                )
            elif comp.track_height is not None:
                dp = int(comp.track_height)
                lines.extend(
                    emit_test(
                        f"Track height {dp}dp",
                        f"ASSERT_EQ({fn}_track({dp}, 1.f), MD3_OK);",
                        f"ASSERT_TRUE({fn}_track({dp + 1}, 1.f) & MD3_SIZE_MISMATCH);",
                        f"ASSERT_TRUE({fn}_track({dp - 1}, 1.f) & MD3_SIZE_MISMATCH);",
                    )
                )

        # Corner radius (with token reference support)
        corner_dp = None
        corner_label = None
        if comp.corner_radius_token is not None:
            # Resolve token to dp value
            token_values = {
                "none": 0,
                "extra_small": 4,
                "small": 8,
                "medium": 12,
                "large": 16,
                "extra_large": 28,
            }
            corner_dp = token_values.get(comp.corner_radius_token, 0)
            corner_label = f"@shape.{comp.corner_radius_token} ({corner_dp}dp)"
        elif comp.corner_radius is not None:
            corner_dp = int(comp.corner_radius)
            corner_label = f"{corner_dp}dp"

        if corner_dp is not None:
            lines.extend(
                emit_test(
                    f"Corner radius {corner_label}",
                    f"ASSERT_EQ({fn}_corner({corner_dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_corner({corner_dp + 1}, 1.f) & MD3_CORNER_RADIUS);",
                    (
                        f"ASSERT_TRUE({fn}_corner({corner_dp - 1}, 1.f) & MD3_CORNER_RADIUS);"
                        if corner_dp > 0
                        else ""
                    ),
                    (
                        f"ASSERT_EQ({fn}_corner({corner_dp * 2}, 2.f), MD3_OK);"
                        if corner_dp > 0
                        else ""
                    ),
                )
            )
            # Clean up empty lines
            lines = [l for l in lines if l.strip()]

        # Touch target
        if comp.touch_target is not None:
            dp = int(comp.touch_target)
            lines.extend(
                emit_test(
                    f"Touch target {dp}dp",
                    f"ASSERT_EQ({fn}_touch({dp}, {dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_touch({dp - 1}, {dp}, 1.f) & MD3_TOUCH_TARGET);",
                    f"ASSERT_TRUE({fn}_touch({dp}, {dp - 1}, 1.f) & MD3_TOUCH_TARGET);",
                    f"ASSERT_EQ({fn}_touch({dp * 2}, {dp * 2}, 2.f), MD3_OK);",
                )
            )

        # Thumb
        if comp.thumb_idle is not None and comp.thumb_pressed is not None:
            idle, pressed = int(comp.thumb_idle), int(comp.thumb_pressed)
            lines.extend(
                emit_test(
                    f"Thumb idle {idle}dp, pressed {pressed}dp",
                    f"ASSERT_EQ({fn}_thumb({idle}, 0, 1.f), MD3_OK);",
                    f"ASSERT_EQ({fn}_thumb({pressed}, 1, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_thumb({pressed}, 0, 1.f) & MD3_THUMB_SIZE);",
                    f"ASSERT_TRUE({fn}_thumb({idle}, 1, 1.f) & MD3_THUMB_SIZE);",
                )
            )
        elif comp.thumb_size is not None:
            dp = int(comp.thumb_size)
            lines.extend(
                emit_test(
                    f"Thumb size {dp}dp",
                    f"ASSERT_EQ({fn}_thumb({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_thumb({dp + 1}, 1.f) & MD3_THUMB_SIZE);",
                    f"ASSERT_TRUE({fn}_thumb({dp - 1}, 1.f) & MD3_THUMB_SIZE);",
                )
            )

        # Icon size
        if comp.icon_size is not None:
            dp = int(comp.icon_size)
            lines.extend(
                emit_test(
                    f"Icon size {dp}dp",
                    f"ASSERT_EQ({fn}_icon({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_icon({dp + 1}, 1.f) & MD3_ICON_SIZE);",
                    f"ASSERT_TRUE({fn}_icon({dp - 1}, 1.f) & MD3_ICON_SIZE);",
                    f"ASSERT_EQ({fn}_icon({dp * 2}, 2.f), MD3_OK);",
                )
            )

        # Width
        if comp.width_exact is not None:
            dp = int(comp.width_exact)
            lines.extend(
                emit_test(
                    f"Exact width {dp}dp",
                    f"ASSERT_EQ({fn}_width({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_width({dp + 1}, 1.f) & MD3_SIZE_MISMATCH);",
                    f"ASSERT_TRUE({fn}_width({dp - 1}, 1.f) & MD3_SIZE_MISMATCH);",
                    f"ASSERT_EQ({fn}_width({dp * 2}, 2.f), MD3_OK);",
                )
            )
        elif comp.min_width is not None:
            dp = int(comp.min_width)
            lines.extend(
                emit_test(
                    f"Min width {dp}dp",
                    f"ASSERT_EQ({fn}_width({dp}, 1.f), MD3_OK);",
                    f"ASSERT_EQ({fn}_width({dp + 10}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_width({dp - 1}, 1.f) & MD3_WIDTH_LOW);",
                    f"ASSERT_EQ({fn}_width({dp * 2}, 2.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_width({dp * 2 - 1}, 2.f) & MD3_WIDTH_LOW);",
                )
            )

        # Padding
        if comp.padding is not None:
            dp = int(comp.padding)
            lines.extend(
                emit_test(
                    f"Padding {dp}dp",
                    f"ASSERT_EQ({fn}_padding({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_padding({dp + 1}, 1.f) & MD3_PADDING);",
                    f"ASSERT_TRUE({fn}_padding({dp - 1}, 1.f) & MD3_PADDING);",
                )
            )
        if comp.padding_h is not None:
            dp = int(comp.padding_h)
            lines.extend(
                emit_test(
                    f"Padding horizontal {dp}dp",
                    f"ASSERT_EQ({fn}_padding_h({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_padding_h({dp + 1}, 1.f) & MD3_PADDING);",
                    f"ASSERT_TRUE({fn}_padding_h({dp - 1}, 1.f) & MD3_PADDING);",
                )
            )
        if comp.padding_v is not None:
            dp = int(comp.padding_v)
            lines.extend(
                emit_test(
                    f"Padding vertical {dp}dp",
                    f"ASSERT_EQ({fn}_padding_v({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_padding_v({dp + 1}, 1.f) & MD3_PADDING);",
                    f"ASSERT_TRUE({fn}_padding_v({dp - 1}, 1.f) & MD3_PADDING);",
                )
            )

        # Item height
        if comp.item_height is not None:
            dp = int(comp.item_height)
            lines.extend(
                emit_test(
                    f"Item height {dp}dp",
                    f"ASSERT_EQ({fn}_item_height({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_item_height({dp + 1}, 1.f) & MD3_SIZE_MISMATCH);",
                    f"ASSERT_TRUE({fn}_item_height({dp - 1}, 1.f) & MD3_SIZE_MISMATCH);",
                    f"ASSERT_EQ({fn}_item_height({dp * 2}, 2.f), MD3_OK);",
                )
            )

        # Icon container
        if comp.icon_container is not None:
            dp = int(comp.icon_container)
            lines.extend(
                emit_test(
                    f"Icon container {dp}dp",
                    f"ASSERT_EQ({fn}_icon_container({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_icon_container({dp + 1}, 1.f) & MD3_SIZE_MISMATCH);",
                    f"ASSERT_TRUE({fn}_icon_container({dp - 1}, 1.f) & MD3_SIZE_MISMATCH);",
                )
            )

        # Button height
        if comp.button_height is not None:
            dp = int(comp.button_height)
            lines.extend(
                emit_test(
                    f"Button height {dp}dp",
                    f"ASSERT_EQ({fn}_button_height({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_button_height({dp + 1}, 1.f) & MD3_HEIGHT_LOW);",
                    f"ASSERT_TRUE({fn}_button_height({dp - 1}, 1.f) & MD3_HEIGHT_LOW);",
                )
            )

        # Drag handle
        if comp.drag_handle_width is not None:
            dp = int(comp.drag_handle_width)
            lines.extend(
                emit_test(
                    f"Drag handle width {dp}dp",
                    f"ASSERT_EQ({fn}_drag_handle_width({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_drag_handle_width({dp + 1}, 1.f) & MD3_SIZE_MISMATCH);",
                    f"ASSERT_TRUE({fn}_drag_handle_width({dp - 1}, 1.f) & MD3_SIZE_MISMATCH);",
                )
            )
        if comp.drag_handle_height is not None:
            dp = int(comp.drag_handle_height)
            lines.extend(
                emit_test(
                    f"Drag handle height {dp}dp",
                    f"ASSERT_EQ({fn}_drag_handle_height({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_drag_handle_height({dp + 1}, 1.f) & MD3_SIZE_MISMATCH);",
                    f"ASSERT_TRUE({fn}_drag_handle_height({dp - 1}, 1.f) & MD3_SIZE_MISMATCH);",
                )
            )

        # Minimum height
        if comp.min_height is not None:
            dp = int(comp.min_height)
            lines.extend(
                emit_test(
                    f"Min height {dp}dp",
                    f"ASSERT_EQ({fn}_min_height({dp}, 1.f), MD3_OK);",
                    f"ASSERT_EQ({fn}_min_height({dp + 10}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_min_height({dp - 1}, 1.f) & MD3_HEIGHT_LOW);",
                )
            )

        # Gap
        if comp.gap is not None:
            dp = int(comp.gap)
            lines.extend(
                emit_test(
                    f"Gap {dp}dp",
                    f"ASSERT_EQ({fn}_gap({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_gap({dp + 1}, 1.f) & MD3_GAP);",
                    f"ASSERT_TRUE({fn}_gap({dp - 1}, 1.f) & MD3_GAP);",
                )
            )

        # Indicator
        if comp.indicator_height is not None:
            dp = int(comp.indicator_height)
            lines.extend(
                emit_test(
                    f"Indicator height {dp}dp",
                    f"ASSERT_EQ({fn}_indicator({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_indicator({dp + 1}, 1.f) & MD3_INDICATOR);",
                    f"ASSERT_TRUE({fn}_indicator({dp - 1}, 1.f) & MD3_INDICATOR);",
                )
            )
        if comp.indicator_width is not None:
            dp = int(comp.indicator_width)
            lines.extend(
                emit_test(
                    f"Indicator width {dp}dp",
                    f"ASSERT_EQ({fn}_indicator_width({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_indicator_width({dp + 1}, 1.f) & MD3_INDICATOR);",
                    f"ASSERT_TRUE({fn}_indicator_width({dp - 1}, 1.f) & MD3_INDICATOR);",
                )
            )

        # Icon-label gap
        if comp.icon_label_gap is not None:
            dp = int(comp.icon_label_gap)
            lines.extend(
                emit_test(
                    f"Icon-label gap {dp}dp",
                    f"ASSERT_EQ({fn}_icon_label_gap({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_icon_label_gap({dp + 1}, 1.f) & MD3_GAP);",
                    (
                        f"ASSERT_TRUE({fn}_icon_label_gap({dp - 1}, 1.f) & MD3_GAP);"
                        if dp > 0
                        else ""
                    ),
                )
            )
            lines = [l for l in lines if l.strip()]

        # Action gap
        if comp.action_gap is not None:
            dp = int(comp.action_gap)
            lines.extend(
                emit_test(
                    f"Action gap {dp}dp",
                    f"ASSERT_EQ({fn}_action_gap({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_action_gap({dp + 1}, 1.f) & MD3_GAP);",
                    (
                        f"ASSERT_TRUE({fn}_action_gap({dp - 1}, 1.f) & MD3_GAP);"
                        if dp > 0
                        else ""
                    ),
                )
            )
            lines = [l for l in lines if l.strip()]

        # Avatar size
        if comp.avatar_size is not None:
            dp = int(comp.avatar_size)
            lines.extend(
                emit_test(
                    f"Avatar size {dp}dp",
                    f"ASSERT_EQ({fn}_avatar({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_avatar({dp + 1}, 1.f) & MD3_SIZE_MISMATCH);",
                    f"ASSERT_TRUE({fn}_avatar({dp - 1}, 1.f) & MD3_SIZE_MISMATCH);",
                )
            )

        # Divider inset
        if comp.divider_inset is not None:
            dp = int(comp.divider_inset)
            lines.extend(
                emit_test(
                    f"Divider inset {dp}dp",
                    f"ASSERT_EQ({fn}_divider_inset({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_divider_inset({dp + 1}, 1.f) & MD3_PADDING);",
                    f"ASSERT_TRUE({fn}_divider_inset({dp - 1}, 1.f) & MD3_PADDING);",
                )
            )

        # Offset
        if comp.offset is not None:
            dp = int(comp.offset)
            lines.extend(
                emit_test(
                    f"Offset {dp}dp",
                    f"ASSERT_EQ({fn}_offset({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_offset({dp + 1}, 1.f) & MD3_PADDING);",
                    f"ASSERT_TRUE({fn}_offset({dp - 1}, 1.f) & MD3_PADDING);",
                )
            )

        # Collapsed height
        if comp.collapsed_height is not None:
            dp = int(comp.collapsed_height)
            lines.extend(
                emit_test(
                    f"Collapsed height {dp}dp",
                    f"ASSERT_EQ({fn}_collapsed_height({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_collapsed_height({dp + 1}, 1.f) & MD3_HEIGHT_LOW);",
                    f"ASSERT_TRUE({fn}_collapsed_height({dp - 1}, 1.f) & MD3_HEIGHT_LOW);",
                )
            )

        # Expanded width
        if comp.expanded_width is not None:
            dp = int(comp.expanded_width)
            lines.extend(
                emit_test(
                    f"Expanded width {dp}dp",
                    f"ASSERT_EQ({fn}_expanded_width({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_expanded_width({dp + 1}, 1.f) & MD3_WIDTH_LOW);",
                    f"ASSERT_TRUE({fn}_expanded_width({dp - 1}, 1.f) & MD3_WIDTH_LOW);",
                )
            )

        # Max height
        if comp.max_height is not None:
            dp = int(comp.max_height)
            lines.extend(
                emit_test(
                    f"Max height {dp}dp",
                    f"ASSERT_EQ({fn}_max_height({dp}, 1.f), MD3_OK);",
                    f"ASSERT_EQ({fn}_max_height({dp - 10}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_max_height({dp + 1}, 1.f) & MD3_HEIGHT_LOW);",
                )
            )

        # Max width (only if min_width is not set)
        if comp.max_width is not None and comp.min_width is None:
            dp = int(comp.max_width)
            lines.extend(
                emit_test(
                    f"Max width {dp}dp",
                    f"ASSERT_EQ({fn}_max_width({dp}, 1.f), MD3_OK);",
                    f"ASSERT_EQ({fn}_max_width({dp - 10}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_max_width({dp + 1}, 1.f) & MD3_WIDTH_LOW);",
                )
            )

        # Selector size
        if comp.selector_size is not None:
            dp = int(comp.selector_size)
            lines.extend(
                emit_test(
                    f"Selector size {dp}dp",
                    f"ASSERT_EQ({fn}_selector({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_selector({dp + 1}, 1.f) & MD3_SIZE_MISMATCH);",
                    f"ASSERT_TRUE({fn}_selector({dp - 1}, 1.f) & MD3_SIZE_MISMATCH);",
                )
            )

        # Center dot
        if comp.center_dot is not None:
            dp = int(comp.center_dot)
            lines.extend(
                emit_test(
                    f"Center dot {dp}dp",
                    f"ASSERT_EQ({fn}_center_dot({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_center_dot({dp + 1}, 1.f) & MD3_SIZE_MISMATCH);",
                    f"ASSERT_TRUE({fn}_center_dot({dp - 1}, 1.f) & MD3_SIZE_MISMATCH);",
                )
            )

        # Header height
        if comp.header_height is not None:
            dp = int(comp.header_height)
            lines.extend(
                emit_test(
                    f"Header height {dp}dp",
                    f"ASSERT_EQ({fn}_header_height({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_header_height({dp + 1}, 1.f) & MD3_HEIGHT_LOW);",
                    f"ASSERT_TRUE({fn}_header_height({dp - 1}, 1.f) & MD3_HEIGHT_LOW);",
                )
            )

        # Suggestion height
        if comp.suggestion_height is not None:
            dp = int(comp.suggestion_height)
            lines.extend(
                emit_test(
                    f"Suggestion height {dp}dp",
                    f"ASSERT_EQ({fn}_suggestion_height({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_suggestion_height({dp + 1}, 1.f) & MD3_HEIGHT_LOW);",
                    f"ASSERT_TRUE({fn}_suggestion_height({dp - 1}, 1.f) & MD3_HEIGHT_LOW);",
                )
            )

        # Content spacing
        if comp.content_spacing is not None:
            dp = int(comp.content_spacing)
            lines.extend(
                emit_test(
                    f"Content spacing {dp}dp",
                    f"ASSERT_EQ({fn}_content_spacing({dp}, 1.f), MD3_OK);",
                    f"ASSERT_TRUE({fn}_content_spacing({dp + 1}, 1.f) & MD3_GAP);",
                    f"ASSERT_TRUE({fn}_content_spacing({dp - 1}, 1.f) & MD3_GAP);",
                )
            )

        lines.append("    PASS();")
        lines.append("}")
        lines.append("")

    # Runner
    lines.append("static void run_md3_gen_tests(void)")
    lines.append("{")
    for name in spec.components:
        lines.append(f"    test_md3_gen_{name}();")
    lines.append("}")
    lines.append("")

    return "\n".join(lines)


# =============================================================================
# Main
# =============================================================================


def main():
    script_dir = Path(__file__).parent
    project_root = script_dir.parent

    dsl_path = project_root / "src" / "md3-spec.dsl"
    flags_path = project_root / "src" / "md3-flags-gen.inc"
    header_path = project_root / "src" / "md3-validate-gen.inc"
    tests_path = project_root / "tests" / "test-md3-gen.inc"

    if not dsl_path.exists():
        print(f"Error: {dsl_path} not found", file=sys.stderr)
        sys.exit(1)

    spec = parse_dsl(dsl_path.read_text())
    print(f"Parsed {len(spec.components)} components from DSL")

    # Generate violation flags enum (single source of truth)
    flags_path.write_text(generate_flags_file())
    print(f"Generated: {flags_path}")

    header_path.write_text(generate_header(spec))
    print(f"Generated: {header_path}")

    tests_path.write_text(generate_tests(spec))
    print(f"Generated: {tests_path}")

    print("Done!")


if __name__ == "__main__":
    main()
